import{_ as a,c as s,a0 as e,o as n}from"./chunks/framework.CoVXEd1Z.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"work/rsa.md","filePath":"work/rsa.md"}'),r={name:"work/rsa.md"};function o(l,t,i,p,d,c){return n(),s("div",null,t[0]||(t[0]=[e(`<h4 id="什么是-rsa-加密" tabindex="-1">什么是 RSA 加密 <a class="header-anchor" href="#什么是-rsa-加密" aria-label="Permalink to &quot;什么是 RSA 加密&quot;">​</a></h4><p>RSA 加密是一种在前端（通常是在浏览器中）进行的非对称加密方法；RSA 是一种公开密钥加密算法，包含两个密钥：公开密钥和私有密钥。通过前端 RSA 加密，可以在客户端对敏感数据进行加密，然后将加密后的数据发送到服务器。</p><h4 id="使用-rsa-加密的一般步骤" tabindex="-1">使用 RSA 加密的一般步骤： <a class="header-anchor" href="#使用-rsa-加密的一般步骤" aria-label="Permalink to &quot;使用 RSA 加密的一般步骤：&quot;">​</a></h4><ol><li><strong>生成密钥对</strong>：首先使用 RSA 算法生成一个密钥对，包含一个公开密钥和一个私有密钥。公开密钥用于加密数据，私有密钥用于解密数据。</li><li><strong>分发公开密钥</strong>：服务器将生成的公开密钥发送给客户端。</li><li><strong>客户端</strong> <strong>加密</strong> <strong>数据</strong>：客户端使用从服务器接收到的公开密钥对要传输的数据进行加密。</li><li><strong>数据传输</strong>：客户端将加密后的数据发送给服务器。</li><li><strong>服务器</strong> <strong>解密数据</strong>：服务器使用它的私有密钥对接收到的加密数据进行解密，得到原始数据。</li></ol><h4 id="项目中实践" tabindex="-1">项目中实践 <a class="header-anchor" href="#项目中实践" aria-label="Permalink to &quot;项目中实践&quot;">​</a></h4><p><code>JSEncrypt</code> 库通常基于 RSA 算法， 通常是服务端同学把公钥给到我们前端进行加密，我们把加密后的内容发送给服务端进行解密；</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>import JSEncrypt from &quot;jsencrypt&quot;; // 引用包</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const devPublicKey = \`-----BEGIN PUBLIC KEY-----MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBALm5F6cLhsY9kzVYZaHjnVZLkcG/zaeaTBkB769z4o1naAuYJBvu8TaFa1O9Uc0t0NLb6l0ONYydeUPu5ewV9IMCAwEAAQ==-----END PUBLIC KEY-----\`;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const rsa = new JSEncrypt(); // 创建实例</span></span>
<span class="line"><span>rsa.setPublicKey(devPublicKey); //设置公钥</span></span>
<span class="line"><span>const res = rsa.encrypt(content); // 对内容进行加密</span></span></code></pre></div><h4 id="faq" tabindex="-1">FAQ <a class="header-anchor" href="#faq" aria-label="Permalink to &quot;FAQ&quot;">​</a></h4><h5 id="加密超长邮箱时-为什么会导致失败" tabindex="-1">加密超长邮箱时 为什么会导致失败？ <a class="header-anchor" href="#加密超长邮箱时-为什么会导致失败" aria-label="Permalink to &quot;加密超长邮箱时 为什么会导致失败？&quot;">​</a></h5><p>首先明确 RSA 的消息长度限制是由于公钥加密的固有特性引起的；</p><p>RSA 的密钥大小（key size）直接影响能加密的最大数据块大小；</p><h6 id="rsa-密钥大小与-加密-数据块的关系" tabindex="-1"><strong>RSA 密钥大小与</strong> <strong>加密</strong> <strong>数据块的关系</strong> <a class="header-anchor" href="#rsa-密钥大小与-加密-数据块的关系" aria-label="Permalink to &quot;**RSA 密钥大小与** **加密** **数据块的关系**&quot;">​</a></h6><table tabindex="0"><thead><tr><th>秘钥大小（Key Size）</th><th>最大加密数据大小</th><th>适用场合</th></tr></thead><tbody><tr><td>512-bit</td><td>53 bytes</td><td>已不再推荐使用，安全性不足。</td></tr><tr><td>1024-bit</td><td>1. 117 bytes</td><td>基本可以用于加密较短的字符串，同样安全性在现代应用中不推荐。</td></tr><tr><td>2048-bit</td><td>245 bytes</td><td>推荐使用，安全性较高，更适合长期数据保护</td></tr></tbody></table><h6 id="常见字符集的字节数" tabindex="-1"><strong>常见字符集的字节数</strong> <a class="header-anchor" href="#常见字符集的字节数" aria-label="Permalink to &quot;**常见字符集的字节数**&quot;">​</a></h6><ol><li><p><strong>ASCII（包括常见英文字符和数字）</strong> ：每个字符占 1 byte</p></li><li><p><strong>UTF-8（包括多语言字符）</strong> ：</p><ol><li>多数英文字符和数字：每个字符占 1 byte</li><li>部分特殊字符和汉字：每个字符占 2-4 bytes</li></ol></li></ol><p>通过以上内容可知：</p><p>此次 bug 导致的原因就是服务端同学提供给我们的 <strong>公钥</strong> 过小导致 ;</p><p>解决方案：</p><ol><li>限制内容输入字符数，建议 40 以内比较安全</li><li>服务端同学生成更大的公钥提供给我们</li></ol><p>Online RSA Key Generator：</p><blockquote><p><a href="https://travistidwell.com/jsencrypt/demo/index.html" target="_blank" rel="noreferrer">https://travistidwell.com/jsencrypt/demo/index.html</a></p></blockquote>`,21)]))}const g=a(r,[["render",o]]);export{b as __pageData,g as default};
